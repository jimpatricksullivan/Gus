ig.module( 
	'game.main' 
)
.requires(
	'impact.game',
	'impact.font',
	'game.entities.player',
	'game.entities.loot',
	'game.entities.droppable',
	'game.entities.explosion'
)
.defines(function(){

MyGame = ig.Game.extend({

	// impact properties
	gravity: 300,
	font: new ig.Font( 'media/04b03.font.png' ),
	
	// custom properties
	tileSize:16,
	scrolled: false,
	player:null,
	timer:null,
	finishedDemo:false,
	inventoryButtons:null,
	inventoryButtonHeight:12,
	inventoryButtonSpace:4,
	droppedDroppable:null,
	//testLevelJSON: '{"droppable":{"tnt":8,"directional-up":0,"directional-right":2,"directional-down":0,"directional-left":0,"mega":2,"gravel":2,"anti-grav":2},"loot":[null,null,null,null,null,null,{"name":"iron","has":0,"needs":0},{"name":"copper","has":0,"needs":0},{"name":"silver","has":0,"needs":5},{"name":"gold","has":0,"needs":4},{"name":"diamond","has":0,"needs":0}],"map":[[0,0,0,0,0,0],[6,6,6,0,2,2],[0,0,0,0,0,2],[2,6,2,2,0,7],[2,6,2,2,2,0],[0,0,0,2,2,0],[8,7,8,2,2,0],[8,7,8,2,2,0],[0,7,0,2,2,6],[0,7,0,0,0,6],[2,2,2,2,2,6],[2,2,2,2,6,6],[2,2,2,2,6,2],[0,0,0,0,0,0],[2,2,2,2,2,2]]}',
	testLevelJSON: '{"droppable":{"tnt":"3","gravel":"0","directional-up":"0","directional-right":"0","directional-down":"0","directional-left":"0","mega":"0","anti-grav":"0"},"loot":[null,null,null,null,null,null,{"name":"iron","has":"0","needs":0},{"name":"copper","has":"0","needs":0},{"name":"silver","has":"0","needs":0},{"name":"gold","has":"0","needs":0},{"name":"diamond","has":"0","needs":0}],"map":[[0,0,0,0,0,0],[2,7,7,7,2,2],[2,0,0,0,2,2],[2,8,8,8,2,2],[2,0,0,0,2,2],[2,0,0,0,2,2],[2,2,2,14,2,2],[2,2,2,14,2,2],[0,0,0,0,0,0],[2,2,2,2,2,2]]}',
	levelJSON:null,
	level:null,
	map:null,
	levelFinished:false,
	
	// tile constants
	TILE_BACKGROUND: 1,
	TILE_ROCK: 2,
	TILE_GRAVEL: 3,
	TILE_IRON: 7,
	TILE_COPPER: 8,
	TILE_SILVER: 9,
	TILE_GOLD: 10,
	TILE_DIAMOND: 11,
	TILE_ADAMANTIUM: 13,
	TILE_ANTI_GRAV: 14,
	TILE_LASER_RIGHT: 15,
	TILE_LASER_LEFT: 16, 
	
	init: function() {
		
		// get level from URL TODO load levels built into game
		this.levelJSON = decodeURIComponent(
			decodeURI(
				(RegExp('level' + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
			)
		);
		
		// animate torches
		var torch = new ig.AnimationSheet( 'media/tiles.png', 16, 16 );
		this.backgroundAnims['media/tiles.png'] = {
			30: new ig.Animation( torch, 0.1, [30,31,32,33] )
		};
		
		// Bind input
		ig.input.bind( ig.KEY.A, 'left' );
		ig.input.bind( ig.KEY.D, 'right' );
		ig.input.bind( ig.KEY.W, 'up' );
		ig.input.bind( ig.KEY.S, 'down' );
		ig.input.bind( ig.KEY.LEFT_ARROW, 'left' );
		ig.input.bind( ig.KEY.RIGHT_ARROW, 'right' );
		ig.input.bind( ig.KEY.UP_ARROW, 'up' );
		ig.input.bind( ig.KEY.DOWN_ARROW, 'down' );
		ig.input.bind( ig.KEY.MOUSE1, 'click' );
		ig.input.bind( ig.KEY.R, 'restart' );
		ig.input.bind( ig.KEY.SPACE, 'detonate' );
		
		// load level
		this.loadMine();

	},
	
	update: function() {		
		
		// Update all entities and BackgroundMaps
		this.parent();
		
		// define player (this just happens once)
		//if (!this.player) {
		//	this.player = this.getEntitiesByType( EntityPlayer )[0];
		//}
		
		// screen follows the player up and down
		if( this.player && !this.scrolled) {
			this.screen.x = 0;
			this.screen.y = Math.min(
					Math.max(0, // the top
							(this.player.pos.y - ig.system.height*.25)), // the player position plus scroll offset
					(this.map.height*16 - ig.system.height) // the bottom 
			);
		}
		
		// up and down keys scroll screen, left and right snap back TODO animate the jump back to the player
		if ( ig.input.state('up') && this.screen.y > 0) {
			this.screen.y--;
			this.scrolled = true;
		} else if ( ig.input.state('down') && this.screen.y < (this.map.height*16 - ig.system.height) ) {
			this.screen.y++;
			this.scrolled = true;
		} else if ( ig.input.state('left') || ig.input.state('right') ) {
			this.scrolled = false;
		}

		// button click
		if ( ig.input.state('click')) {
			if (100 < ig.input.mouse.x && ig.input.mouse.x < 140) {
				var buttonCounter = 0;
				var buttonStart = 0;
				// loop through buttons to see what was clicked
				for (droppable in this.inventoryButtons) {
					if (this.level.droppable[droppable] > 0) {
						buttonStart = this.inventoryButtonSpace+(buttonCounter*(this.inventoryButtonHeight+this.inventoryButtonSpace));				
						if (buttonStart < ig.input.mouse.y && ig.input.mouse.y < buttonStart+this.inventoryButtonHeight) {
							this.drop(this.inventoryButtons[droppable][2]);				
						}
						buttonCounter++;
					}
				}
				
			}
		}

		// clean up explosions TODO make this work if it doesn't already - easier now since explosions are generated by this class
		var explosions = this.getEntitiesByType(EntityExplosion);
		if (explosions.length > 0 && explosions[0].anims.explode.loopCount > 0) {
			for (var i=0;i<explosions.length;i++) {
				explosions[i].kill();
				explosions[i] = null;
			}
		}	
		
		// check for death
		if (this.player.health == 0 && explosions.length == 0) {
			alert("You have blown yourself up.");
			this.loadMine();
		}
		
		// check for end TODO tutorial stuff and cleaner level complete check
		//console.log(this.player.tile.y);
		//console.log(this.backgroundMaps[0].height);
		if (this.player.standing && !this.levelFinished && this.player.tile.y == this.backgroundMaps[0].height-2) { 
			var wonLevel = true;
			var missing = [];
			for (type in this.level.loot) {
				if (this.level.loot[type] !== null) {
					if (this.level.loot[type]["has"] < this.level.loot[type]["needs"]) {
						var wonLevel = false;	
						var deficit = this.level.loot[type]["needs"] - this.level.loot[type]["has"];
						missing.push({name:this.level.loot[type]["name"], deficit: deficit});
					}
				}
			}
			if (wonLevel) {
				alert("Good Job!");
				this.levelFinished = true;  
			} else {console.log(missing);
				var message = "You reached the bottom, but you need:\n";
				for (i=0;i<missing.length;i++) {
					message = message + missing[i].deficit + " more " + missing[i].name+"\n";
				}
				message = message + "Try again!";
				alert(message);
				this.loadMine();
			}
		/*		if (this.timer == null) {
				this.timer = new ig.Timer();
			} else if (this.timer.delta() > 0.3) {
				var wonLevel = true;
				for (type in this.level.loot) {
					if (this.level.loot[type]["has"] < this.level.loot[type]["needs"]) {
						var wonLevel = false;
					}
				}
				if (wonLevel) {
					if (!this.finishedDemo) {
							//alert("You have finished the alpha demo!  Good job!  Be sure to give Jim any feedback you might have.");
							alert("success");
							this.finishedDemo = true;
							this.player.kill();
					}
				} else {
					alert("you reached the bottom but you didn't collect everything you needed.  Try again.");
					this.loadMine();
				}
			}*/
		}
		
		if (ig.input.state('restart')) {
			this.loadMine();
		}

		if (ig.input.state('detonate') && this.droppedDroppable != null) {
			if (this.droppedDroppable.detonate()) {
				this.droppedDroppable = null;
			}
		}
		

		if (this.droppedDroppable != null && this.droppedDroppable.health <= 0) {
			this.droppedDroppable = null;
		}
		
	},
	
	draw: function() {
		
		// Draw all entities and BackgroundMaps
		this.parent();
		
		var sideBarY = this.inventoryButtonSpace;
		
		for (droppable in this.inventoryButtons) {
			if (this.level.droppable[droppable] > 0) {
				this.inventoryButtons[droppable][0].draw(100, sideBarY);
				this.inventoryButtons[droppable][1].draw(107, sideBarY+2);
				this.font.draw( "x "+this.level.droppable[droppable], 117, sideBarY+4 );
				var sideBarY = sideBarY + this.inventoryButtonHeight + this.inventoryButtonSpace;
			}
		}
		
		// list loot TODO make this fancier
		var lineCounter=2;
		this.font.draw( "--LOOT--", 98, sideBarY+(6*lineCounter) );
		lineCounter++;lineCounter++;
		for (type in this.level.loot) { 
			if (this.level.loot[type] !== null && this.level.loot[type]["needs"] > 0) {
				this.font.draw(this.level.loot[type]["name"]+":"+this.level.loot[type]["has"]+"/"+this.level.loot[type]["needs"], 98, sideBarY+(6*lineCounter));
				lineCounter++;
			}
		}
		
		
		
	},
	
	drop: function(droppableType) {
		if (this.droppedDroppable == null) {
			var dropInTile = this.player.getFacingTile();
			if (this.coordinatesInBounds(dropInTile.x, dropInTile.y) && this.getMapTileMaterial(dropInTile.x, dropInTile.y) == 0) {	
				this.droppedDroppable = ig.game.spawnEntity( EntityDroppable, 0, this.player.pos.y+4, {type: droppableType});
				nextTile = (this.player.tile.x + (this.player.flip ? -1 : 1)) * 16;
				halfTile = 8 - (this.droppedDroppable.size.x/2);
				this.droppedDroppable.pos.x = nextTile + halfTile;
				this.level.droppable[droppableType]--;
			}
		}
	},
	
	// destroy a map tile
	destroyBlock: function(x, y) {
		if (this.coordinatesInBounds(x,y) && this.getTile(x,y) != this.TILE_ADAMANTIUM) {
			
			// drop 
			var explodedMaterial = this.getTile(x,y);
			if (explodedMaterial > 0) {
				xOffset = Math.floor(Math.random()*11+1);
				this.spawnEntity( EntityLoot, x*16+xOffset, y*16+8, {lootType: explodedMaterial});
			}
			
			// modify tilemap and collision map
			this.setTile(x,y, 0);
			
			// spawn explosion
			this.spawnEntity( EntityExplosion, x*this.tileSize, y*this.tileSize);
			
			// kill player Gus if he's in this square
			this.killAt(x,y);
		}
	},
	
	// function for destroying a vein with TNT
	// call on any block and if that block is part of a vein, the entire vein will be destroyed
    startDestroyingVein: function(x,y) {
		if (this.coordinatesInBounds(x,y)) {
			this.destroyVein(x, y, this.getMapTileMaterial(x,y));
		}
    },

	// function called by startDestroyingVein() to recursively destroy vein
    destroyVein: function(x,y, material) {
		if (this.coordinatesInBounds(x,y)) {

			// if this tile is an empty space, show an explosion and potentially kill the player
			//TODO remind yourself why this works and comment it
			if (material == 0) {
				ig.game.spawnEntity( EntityExplosion, x*16, y*16);
				ig.game.killAt(x,y);
				return
			}
			
	  		// stop if this material is not in the list of things that dynamite can explode
	  		if (
	  			material != this.TILE_GRAVEL &&
	  			material != this.TILE_IRON &&
	  			material != this.TILE_COPPER &&
	  			material != this.TILE_SILVER &&
	  			material != this.TILE_GOLD &&
	  			material != this.TILE_DIAMOND &&
	  			material != this.TILE_ANTI_GRAV &&
	  			material != this.TILE_LASER_RIGHT &&
	  			material != this.TILE_LASER_LEFT
	  		) {			
				return;
			}
			
			// stop if this tile is a new material
			if (ig.game.getMapTileMaterial(x,y) != material) {
				return;
			}
			
			// explode this tile and branch out
			this.destroyBlock(x,y);
			this.destroyVein(x+1,y,material);
			this.destroyVein(x-1,y,material);
			this.destroyVein(x,y+1,material);
			this.destroyVein(x,y-1,material);
			
		}
    },
	
	// add gravel
	createGravelBlock: function(x,y) {
		this.setTile(x, y, this.TILE_GRAVEL);
		this.destroyLootInTile(x,y);
	},
	
	// add gravel
	createAntigravBlock: function(x,y) {
		if (this.coordinatesInBounds(x,y-1) && this.getTile(x,y-1) == 0) {
			y--;
		}
		this.setTile(x, y, this.TILE_ANTI_GRAV);
		this.destroyLootInTile(x,y);
	},
	
	// kill the player if they are at the given coordinates
	killAt: function(x,y) {
		if (this.player && this.player.tile.y == y && this.player.tile.x == x) {
			this.player.receiveDamage( 10, null);
		}
	},
	
	// check a map tile's material
	getMapTileMaterial: function(x,y) {
		return this.getTile(x,y)
	},
	
	// functions for manipulating inventory items
	takeLoot: function(lootEntity) {
		if (lootEntity.lootType == this.TILE_ROCK || lootEntity.lootType == this.TILE_GRAVEL) {
			this.getDroppable('gravel');
		} else if (lootEntity.lootType == this.TILE_ANTI_GRAV) {
			this.getDroppable('anti-grav');
		} else if (this.level.loot.hasOwnProperty(lootEntity.lootType)) {
			this.level.loot[lootEntity.lootType-1].has++;
		}
		lootEntity.kill();
		lootEntity = null;
	},

	destroyLootInTile: function(x,y) {
		loots = ig.game.getEntitiesByType( EntityLoot );
		for (var i=0;i<loots.length;i++) {
			if (loots[i].tile.x == x && loots[i].tile.y == y) {
				loots[i].kill();
				loots[i] = null;
			}	
		}
	},

	getDroppable: function(droppable) {
		this.level.droppable[droppable]++;
	},


	loseDroppable: function(droppable) {
		this.level.droppable[droppable]--;
	},

	countDroppable: function(droppable) {
		return this.level.droppable[droppable];
	},

	coordinatesInBounds: function(x, y) {
		if (x >= 0 && x <= 5 && y >= 0 && y < this.map.height) {
			return true;
		}
		return false;
	},

	// function for loading a level
	loadMine: function() {
		
		// reset everything
		this.timer = null;
		this.player = null;
		this.scrolled = false;
		
		// copy and load level
		//this.level = jQuery.extend(true, {}, this.levelArray[this.levelNumber]); // create a copy of the current level

		this.loadLevel();
		
		// create inventory buttons
		this.inventoryButtons = new Object();
		for (droppable in this.level.droppable) {
			this.inventoryButtons[droppable] = [
				new ig.Image( 'media/button.png' ),
				new ig.Image( 'media/droppable-'+droppable+'.png' ),
				droppable
			];
		}
		
	},


	loadLevel: function( ) {
		
		this.level = JSON.parse(this.levelJSON);
		
		//TODO more sophisticated background editing, for now we use ths isFirstLevel variable which is super hacky
		if (this.level.map[0][0] == 19) {
			var isFirstLevel = true;
			console.log('first level');
		} else {
			var isFirstLevel = false;
		}
		
		this.screen = {x: 0, y: 0};

		// Entities
		this.entities = [];
		this.namedEntities = {};
		this.player = this.spawnEntity( EntityPlayer, 4,2);
		this.sortEntities();
		
		// Map Layer
		this.collisionMap = ig.CollisionMap.staticNoCollision;
		this.backgroundMaps = [];
		
		// build collision map and simple repeating background map 
		var cMap = [];
		var bgMap = []
		for (row in this.level.map) {
		    cMap[row] = [];
		    bgMap[row] = [];
		    for (column in this.level.map[row]) {
				
				if (this.level.map[row][column] == 0) {
				    cMap[row][column] = 0;
				} else {
				    cMap[row][column] = 1;
				}
				bgMap[row][column] = this.TILE_BACKGROUND;
				
				if (isFirstLevel && row < 2) {
					cMap[row][column] = 0;
					bgMap[row][column] = this.level.map[row][column];
					this.level.map[row][column] = 0;
					this.player.pos.y = 20
				} 
				
			}
		}
		bgMap[bgMap.length-2] = [1,31,1,1,31,1];
		if (!isFirstLevel) {
			bgMap[0] = [1,31,1,1,31,1];
		} 
		
		// set collision map
		this.collisionMap = new ig.CollisionMap(16, cMap );
		
		// set background map
		var newMap = new ig.BackgroundMap(16, bgMap, 'media/tiles.png');
		newMap.anims = this.backgroundAnims['media/tiles.png'] || {};
		newMap.repeat = false;
		newMap.distance = 1;
		newMap.foreground = false;
		newMap.preRender = false;
		this.backgroundMaps.push( newMap );
		
		// tile map	
		var newMap = new ig.BackgroundMap(16, this.level.map, 'media/tiles.png');
		newMap.anims = this.backgroundAnims['media/tiles.png'] || {};
		newMap.repeat = false;
		newMap.distance = 1;
		newMap.foreground = false;
		newMap.preRender = false;
		this.backgroundMaps.push( newMap );
		
		// set map variable for easy access later
		this.map = this.backgroundMaps[1];
		
		if (this.droppedDroppable !== null) {
			this.droppedDroppable.kill();
			this.droppedDroppable = null;
		}	

			
		// Call post-init ready function on all entities
		for( var i = 0; i < this.entities.length; i++ ) {
			this.entities[i].ready();
		}
		
	},

	// functions for getting and setting tiles based on tile coords
	getTile: function(x,y) {
		return this.map.data[y][x];
	},	
	setTile: function(x,y,tile) {
		this.map.data[y][x] = tile;
		if (tile == 0) {
			this.collisionMap.data[y][x] = 0;
		} else {
			this.collisionMap.data[y][x] = 1;
		}
	},	

});

// (canvas element, game object, fps, width, height, scale)
ig.main( '#canvas', MyGame, 60, 144, 128, 4);

});
