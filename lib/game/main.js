ig.module( 
	'game.main' 
)
.requires(
	'impact.game',
	'impact.font',
	'game.entities.player',
	'game.entities.loot',
	'game.entities.droppable',
	'game.entities.explosion'
)
.defines(function(){

MyGame = ig.Game.extend({
	
	// impact properties
	gravity: 300,
	font: new ig.Font( 'media/04b03.font.png' ),
	
	// custom properties
	tileSize:16,
	scrolled: false,
	player:null,
	timer:null,
	finishedDemo:false,
	inventoryButtons:null,
	inventoryButtonHeight:12,
	inventoryButtonSpace:4,
	droppedDroppable:null,
	testLevelJSON: '{"droppable":{"tnt":8,"directional-up":0,"directional-right":2,"directional-down":0,"directional-left":0,"mega":2,"gravel":2,"anti-grav":2},"loot":[null,null,null,null,null,null,{"name":"iron","has":0,"needs":0},{"name":"copper","has":0,"needs":0},{"name":"silver","has":0,"needs":5},{"name":"gold","has":0,"needs":4},{"name":"diamond","has":0,"needs":0}],"map":[[0,0,0,0,0,0],[6,6,6,0,2,2],[0,0,0,0,0,2],[2,6,2,2,0,7],[2,6,2,2,2,0],[0,0,0,2,2,0],[8,7,8,2,2,0],[8,7,8,2,2,0],[0,7,0,2,2,6],[0,7,0,0,0,6],[2,2,2,2,2,6],[2,2,2,2,6,6],[2,2,2,2,6,2],[0,0,0,0,0,0],[2,2,2,2,2,2]]}',
	level:null,
	map:null,
	
	
	init: function() {
		
		// animate torches
		var torch = new ig.AnimationSheet( 'media/minetiles2.png', 16, 16 );
		this.backgroundAnims['media/minetiles2.png'] = {
			10: new ig.Animation( torch, 0.1, [10,11,12,13] )
		};
		
		// Bind input
		ig.input.bind( ig.KEY.A, 'left' );
		ig.input.bind( ig.KEY.D, 'right' );
		ig.input.bind( ig.KEY.W, 'up' );
		ig.input.bind( ig.KEY.S, 'down' );
		ig.input.bind( ig.KEY.LEFT_ARROW, 'left' );
		ig.input.bind( ig.KEY.RIGHT_ARROW, 'right' );
		ig.input.bind( ig.KEY.UP_ARROW, 'up' );
		ig.input.bind( ig.KEY.DOWN_ARROW, 'down' );
		//ig.input.bind( ig.KEY.Z, 'tnt' );
		ig.input.bind( ig.KEY.MOUSE1, 'click' );
		//ig.input.bind( ig.KEY.X, 'explode' );
		//ig.input.bind( ig.KEY.C, 'gravel' );
		ig.input.bind( ig.KEY.R, 'restart' );
		ig.input.bind( ig.KEY.SPACE, 'detonate' );
		
		// load level
		this.loadMine();

	},
	
	update: function() {		
		
		// Update all entities and BackgroundMaps
		this.parent();
		
		// define player (this just happens once)
		if (!this.player) {
			this.player = this.getEntitiesByType( EntityPlayer )[0];
		}
		
		// screen follows the player up and down
		if( this.player && !this.scrolled) {
			this.screen.x = 0;
			this.screen.y = Math.min(
					Math.max(0, // the top
							(this.player.pos.y - ig.system.height*.25)), // the player position plus scroll offset
					(this.map.height*16 - ig.system.height) // the bottom 
			);
		}
		
		// up and down keys scroll screen, left and right snap back TODO animate the jump back to the player
		if ( ig.input.state('up') && this.screen.y > 0) {
			this.screen.y--;
			this.scrolled = true;
		} else if ( ig.input.state('down') && this.screen.y < (this.map.height*16 - ig.system.height) ) {
			this.screen.y++;
			this.scrolled = true;
		} else if ( ig.input.state('left') || ig.input.state('right') ) {
			this.scrolled = false;
		}

		// button click
		if ( ig.input.state('click')) {
			if (100 < ig.input.mouse.x && ig.input.mouse.x < 140) {
				var buttonCounter = 0;
				var buttonStart = 0;
				for (droppable in this.inventoryButtons) {
					if (this.level.droppable[droppable] > 0) {
						buttonStart = this.inventoryButtonSpace+(buttonCounter*(this.inventoryButtonHeight+this.inventoryButtonSpace));				
						if (buttonStart < ig.input.mouse.y && ig.input.mouse.y < buttonStart+this.inventoryButtonHeight) {
							this.drop(this.inventoryButtons[droppable][2]);				
						}
						buttonCounter++;
					}
				}
				
			}
		}

		// clean up explosions TODO make this work if it doesn't already - easier now since explosions are generated by this class
		var explosions = this.getEntitiesByType(EntityExplosion);
		if (explosions.length > 0 && explosions[0].anims.explode.loopCount > 0) {
			for (var i=0;i<explosions.length;i++) {
				explosions[i].kill();
				explosions[i] = null;
			}
		}	
		
		// check for death
		if (this.player.health == 0 && explosions.length == 0) {
			alert("You have blown yourself up.");
			this.loadMine();
		}
		
		// check for end TODO tutorial stuff
		if (this.player.standing && this.player.tile.y == this.map.length-2) {
			if (this.timer == null) {
				this.timer = new ig.Timer();
			} else if (this.timer.delta() > 0.3) {
				var wonLevel = true;
				for (type in this.level.loot) {
					if (this.level.loot[type]["has"] < this.level.loot[type]["needs"]) {
						var wonLevel = false;
					}
				}
				if (wonLevel) {
					if (!this.finishedDemo) {
							//alert("You have finished the alpha demo!  Good job!  Be sure to give Jim any feedback you might have.");
							alert("success");
							this.finishedDemo = true;
							this.player.kill();
					}
				} else {
					alert("you reached the bottom but you didn't collect everything you needed.  Try again.");
					this.loadMine();
				}
			}
		}
		
		if (ig.input.state('restart')) {
			this.loadMine();
		}

		if (ig.input.state('detonate') && this.droppedDroppable != null) {
			if (this.droppedDroppable.detonate()) {
				this.droppedDroppable = null;
			}
		}
		

		if (this.droppedDroppable != null && this.droppedDroppable.health <= 0) {
			this.droppedDroppable = null;
		}
		
	},
	
	draw: function() {
		
		// Draw all entities and BackgroundMaps
		this.parent();
		
		var sideBarY = this.inventoryButtonSpace;
		
		for (droppable in this.inventoryButtons) {
			if (this.level.droppable[droppable] > 0) {
				this.inventoryButtons[droppable][0].draw(100, sideBarY);
				this.inventoryButtons[droppable][1].draw(107, sideBarY+2);
				this.font.draw( "x "+this.level.droppable[droppable], 117, sideBarY+4 );
				var sideBarY = sideBarY + this.inventoryButtonHeight + this.inventoryButtonSpace;
			}
		}
		
		// list loot TODO make this fancier
		var lineCounter=2;
		this.font.draw( "--LOOT--", 98, sideBarY+(6*lineCounter) );
		lineCounter++;lineCounter++;
		for (type in this.level.loot) { 
			if (this.level.loot[type] !== null && this.level.loot[type]["needs"] > 0) {
				this.font.draw(this.level.loot[type]["name"]+":"+this.level.loot[type]["has"]+"/"+this.level.loot[type]["needs"], 98, sideBarY+(6*lineCounter));
				lineCounter++;
			}
		}
		
		
		
	},
	
	drop: function(droppableType) {
		if (this.droppedDroppable == null) {
			var dropInTile = this.player.getFacingTile();
			if (this.coordinatesInBounds(dropInTile.x, dropInTile.y) && this.getMapTileMaterial(dropInTile.x, dropInTile.y) == 0) {	
				this.droppedDroppable = ig.game.spawnEntity( EntityDroppable, 0, this.player.pos.y+4, {type: droppableType});
				nextTile = (this.player.tile.x + (this.player.flip ? -1 : 1)) * 16;
				halfTile = 8 - (this.droppedDroppable.size.x/2);
				this.droppedDroppable.pos.x = nextTile + halfTile;
				this.level.droppable[droppableType]--;
			}
		}
	},
	
	// destroy a map tile
	destroyBlock: function(x, y) {
		if (this.coordinatesInBounds(x,y)) {
			
			// drop 
			var explodedMaterial = this.getMapTileMaterial(x,y);
			if (explodedMaterial > 0) {
				xOffset = Math.floor(Math.random()*11+1);
				this.spawnEntity( EntityLoot, x*16+xOffset, y*16+8, {lootType: explodedMaterial});
			}
			
			// modify tilemap and collision map
			this.setTile(x,y,0);
			
			// spawn explosion
			this.spawnEntity( EntityExplosion, x*this.tileSize, y*this.tileSize);
			
			// kill player Gus if he's in this square
			this.killAt(x,y);
		}
	},
	
	// function for destroying a vein with TNT
	// call on any block and if that block is part of a vein, the entire vein will be destroyed
    startDestroyingVein: function(x,y) {
		if (this.coordinatesInBounds(x,y)) {
			this.destroyVein(x, y, this.getMapTileMaterial(x,y));
		}
    },

	// function called by startDestroyingVein() to recursively destroy vein
    destroyVein: function(x,y, material) {
		if (this.coordinatesInBounds(x,y)) {

			// if this tile is an empty space, show an explosion and potentially kill the player
			// TODO remind yourself why this works and comment it
			if (material == 0) {
				ig.game.spawnEntity( EntityExplosion, x*16, y*16);
				ig.game.killAt(x,y);
				return
			}
			
	  		// stop if this tile is not explodable via TNT
			if (material < 3) {			
				return;
			}
			
			// stop if this tile is a new material
			if (ig.game.getMapTileMaterial(x,y) != material) {
				return;
			}
			
			// explode this tile and branch out
			this.destroyBlock(x,y);
			this.destroyVein(x+1,y,material);
			this.destroyVein(x-1,y,material);
			this.destroyVein(x,y+1,material);
			this.destroyVein(x,y-1,material);
			
		}
    },
	
	// add gravel
	createGravelBlock: function(x,y) {
		this.setTile(x,y,3);
	},
	
	// add gravel
	createAntigravBlock: function(x,y) {
		this.setTile(x,y-1,4);
	},
	
	// kill the player if they are at the given coordinates
	killAt: function(x,y) {
		if (this.player && this.player.tile.y == y && this.player.tile.x == x) {
			this.player.receiveDamage( 10, null);
		}
	},
	
	// check a map tile's material
	getMapTileMaterial: function(x,y) {
		return this.getTile(x,y)
	},
	
	// functions for manipulating inventory items
	takeLoot: function(lootEntity) {
		if (lootEntity.lootType == 2 || lootEntity.lootType == 3) {
			this.getDroppable('gravel');
		} else if (lootEntity.lootType == 4) {
			this.getDroppable('anti-grav');
		} else if (this.level.loot.hasOwnProperty(lootEntity.lootType)) {
			console.log(lootEntity.lootType);
			this.level.loot[lootEntity.lootType].has++;
		}
		lootEntity.kill();
		lootEntity = null;
	},

	getDroppable: function(droppable) {
		this.level.droppable[droppable]++;
	},


	loseDroppable: function(droppable) {
		this.level.droppable[droppable]--;
	},

	countDroppable: function(droppable) {
		return this.level.droppable[droppable];
	},

	coordinatesInBounds: function(x, y) {
		if (x >= 0 && x <= 5 && y >= 0 && y < this.map.height) {
			return true;
		}
		return false;
	},

	// function for loading a level
	loadMine: function() {
		
		// reset everything
		this.timer = null;
		this.player = null;
		this.scrolled = false;
		
		// copy and load level
		//this.level = jQuery.extend(true, {}, this.levelArray[this.levelNumber]); // create a copy of the current level

		this.loadLevel();
		
		// create inventory buttons
		this.inventoryButtons = new Object();
		for (droppable in this.level.droppable) {
			this.inventoryButtons[droppable] = [
				new ig.Image( 'media/button.png' ),
				new ig.Image( 'media/droppable-'+droppable+'.png' ),
				droppable
			];
		}
		
	},


	loadLevel: function( ) {
		
		this.level = JSON.parse(this.testLevelJSON);
		
		this.screen = {x: 0, y: 0};

		// Entities
		this.entities = [];
		this.namedEntities = {};
		this.spawnEntity( EntityPlayer, 4,2);
		this.sortEntities();
		
		// Map Layer
		this.collisionMap = ig.CollisionMap.staticNoCollision;
		this.backgroundMaps = [];
		
		// build collision map and simple repeating background map TODO make background more sophisticated for futuristic levels
		var cMap = [];
		var bgMap = []
		for (row in this.level.map) {
		    cMap[row] = [];
		    bgMap[row] = [];
		    for (column in this.level.map[row]) {
				if (this.level.map[row][column] == 0) {
				    cMap[row][column] = 0;
				} else {
				    cMap[row][column] = 1;
				
				}
				bgMap[row][column] = 1;
			}
		}
		
		// set collision map
		this.collisionMap = new ig.CollisionMap(16, cMap );
		
		// set background map
		var newMap = new ig.BackgroundMap(16, bgMap, 'media/minetiles2.png');
		newMap.anims = this.backgroundAnims['media/minetiles2.png'] || {};
		newMap.repeat = false;
		newMap.distance = 1;
		newMap.foreground = false;
		newMap.preRender = false;
		this.backgroundMaps.push( newMap );
		
		// tile map	
		var newMap = new ig.BackgroundMap(16, this.level.map, 'media/minetiles2.png');
		newMap.anims = this.backgroundAnims['media/minetiles2.png'] || {};
		newMap.repeat = false;
		newMap.distance = 1;
		newMap.foreground = false;
		newMap.preRender = false;
		this.backgroundMaps.push( newMap );
		
		// set map variable for easy access later
		this.map = this.backgroundMaps[1];
			
			
		// Call post-init ready function on all entities
		for( var i = 0; i < this.entities.length; i++ ) {
			this.entities[i].ready();
		}
		console.log(this.collisionMap );
		
	},

	// functions for getting and setting tiles based on tile coords
	getTile: function(x,y,tile) {
		return this.map.getTile( x*this.tileSize, y*this.tileSize);
	},	
	setTile: function(x,y,tile) {
		console.log("x:"+x+" y:"+y);
		this.map.setTile( x*this.tileSize, y*this.tileSize, tile );
		if (tile == 0) {
			this.collisionMap.setTile( x*this.tileSize, y*this.tileSize, 0 );
		} else {
			this.collisionMap.setTile( x*this.tileSize, y*this.tileSize, 1);
		}
	},	
	
	
});

// (canvas element, game object, fps, width, height, scale)
ig.main( '#canvas', MyGame, 60, 144, 128, 4);

});
